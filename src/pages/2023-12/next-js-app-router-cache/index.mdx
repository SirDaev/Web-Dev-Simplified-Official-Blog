---
layout: "@layouts/BlogPost.astro"
title: "Next.js App Router Caching Mechanisms"
date: "2023-12-15"
description: "Next.js improves your application's performance and reduces costs by caching rendering work and data requests. This article goes in depth about everything you need to know about Next.js's caching mechanisms."
tags: ["Next.js"]
---

import Tangent from "@blogComponents/lib/Tangent.astro";

## Introduction

Next.js is an amazing framework that makes writing complex server rendered React apps much easier, but there is one huge problem. Next.js's caching mechanism is extremely complicated and can easily lead to bugs in your code that are difficult to debug and fix.

If you don't understand how Next.js's caching mechanism works it feels like you are constantly fighting Next.js instead of reaping the amazing benefits of Next.js's powerful caching. That is why in this article I am going to break down exactly how every part of Next.js's cache works so you can stop fighting it and finally take advantage of its incredible performance gains.

If you are not already familiar with React Server Components, I wrote an entire article on it which explains them in depth. You can read that [here](https://blog.webdevsimplified.com/2023-11/react-server-components/).

Here is an image of how all the caches in Next.js interact with one another. I know this is overwhelming, but by the end of this article you will understand exactly what each step in this process does and how they all interact.

![cache-interactions](/articleAssets/2023-12/next-js-app-router-cache/cache-interactions.png)

## Next.js Caching Mechanisms

The main reason Next.js' cache is so hard to understand is because it is
actually broken down into 4 distinct caching mechanisms that all operate on different stages of your application and interact with each other in complicated ways.

The 4 caching mechanisms are:

1. Request Memoization
2. Data Cache
3. Full Route Cache
4. Router Cache

I will be covering each cache's purpose, where it is stored, how long it lasts for, how to invalidate the cache and how to opt out. This seems like a lot of information at first glance but we will take an example based approach.

### Request Memoization

Let's say we have to fetch and display the details of a user in two different places in our application. We create a function called `fetchUserData(userId)` which returns the user details as JSON.
Because there are multiple pages in our application that use the user details, we call `fetchUserData(userId)` multiple times. Assuming they are passed the same `userId`, they will return the same value.

Now, you might be thinking to yourself, wouldn't this make duplicate requests? This would not be ideal, especially if the `fetch` request is computationally heavy.
Luckily, the Request Memoization mechanism addresses exactly this issue. When Next.js is in the process of rendering a page,
Request Memoization caches the return values of `fetch` requests so that the return value for any subsequent request after the first request within the same render process is retrieved from cache.

```jsx {8,17 }
export default async function fetchUserData(userId) {
  // The `fetch` function is automatically memoized by Next.js during SSR
  const res = await fetch(`https://api.example.com/users/${userId}`);
  return res.json();
}

export default async function Page({ params }) {
  const user = await fetchUserData(params.id)

  return <>
    <h1>{user.name}</h1>
    <UserDetails id={params.id} />
  </>
}

function UserDetails({ id }) {
  const user = fetchUserData(id)
  return <p>{user.name}</p>
}
```

As you can see in the code above, both `Page` and `UserDetails` component are making a call to `fetchUserData(userId)`.

`fetchUserData(params.id)` will be cached after being called the first time.
Meaning, when `UserDetails` makes a call to `fetchUserData`, no actual `fetch` call is made. Instead, it is retrieved from the cache.
For Request Memoization to work, all the parameters passed to `fetch` must be identical between the requests for them to be hit in the cache.

Passing a different `userId` to `Page` and `UserDetails` would store results in separate caches.

As you can probably tell, Request Memoization allows us to optimize performance and efficiency during the render process. This is why Next.js has this cache enabled by default.
By memoizing, we reduce the load on the server by skipping redundant calls, thus, serving users data more quickly.

This is all done on the server-side as that's where the render process for Server Components occurs. This cache is **not** persistent. Meaning it only lasts from the time a page starts rendering until it has finished rendering. This is also referred to as a **single render pass**.
As such, these memoized values will be invalidated after all the components have finished rendering for a given page.
From our example above, as soon as our `Page` finishes rendering, the memoized `fetch` values will be deleted.

It should be noted that Request Memoization is a React feature, not a Next.js feature. It's included to demonstrate how it's used in conjuction with other cache mechanisms.

#### Memoization requests other than `fetch`

Sometimes, you might want to retrieve data directly from the database. This could be because we want to bypass the additional overhead and the limitations of an intermediary API layer.
Request Memoization only works for the `GET` method in the `fetch` API. Don't worry though, there is another way to memoize the return values for functions that are not `fetch`.

Let's say that we have a connection to a database and we want to dynamically retrieve all columns from a database given a `userId`. We might want to do this so we can populate a user profile.
Depending on the size of the database, making these calls can be very expensive.

We can use the `cache()` function provided by React to memoize our result and use it across all our components that need this result. This function is a React feature specific to server side components.

```jsx
import { cache } from "react";
import { queryDatabase } from "./databaseClient"; // Assume this is our database client function

export default async function fetchUserData(userId) {
  return cache(async () => {
    // Direct database query
    return queryDatabase("SELECT * FROM users WHERE id = ?", [userId]);
  });
}
```

In the code above, the first time `fetchUserData` is called, it will make a call to the database since there is no cached result. The second time the function is called with the same `userId` in another component, the result will be retrieved
from the cache. Just like the memoization with `fetch`, this is also only valid for a single render pass.

#### Revalidation

Revalidation refers to the process of deleting the old values in memory and making a fresh fetch from the database.
Next.js allows us to set revalidation periods for our caches, which determine how long a piece of data or content remains valid in the cache.
The main purpose is to ensure that the data served to users is not too old and remains relevant.

Currently, there is no way to revalidate the memoized values. Given the short duration of a single render pass, there isn't a practical need for revalidating the memoized requests. The data fetched is unlikely to change during this brief period.

This might sound like a downside but for cases where you need the most up-to-date data, Next.js gives us the option to opt out of the cache.

#### Opting out

Sometimes, our data changes so frequently that we would rather not memoize it. To do this, we pass in an `AbortController` signal as a parameter
to the `fetch` request.

```tsx {1, 4, 5}
const { signal } = new AbortController();
async function fetchUserData(userId) {
  // The `fetch` function is automatically memoized by Next.js during SSR
  const res = await fetch(`https://api.example.com/users/${userId}`, {
    signal,
  });
  return res.json();
}
```

In the code above, when we pass a signal to a `fetch` request, we're essentially saying, "This request may need to be stopped before it finishes, based on certain conditions or events."

Memoization is based on the premise that a request with the same parameters will always yield the same result.
However, with abortable requests, we introduce a level of uncertainty â€“ they might not complete, or their behavior might be influenced by external factors.
If such a request were memoized, and then aborted in a subsequent execution, it would lead to inconsistent or unexpected behavior. Therefore, abortable requests are not memoized making it an effective way to opt out.

The diagram below provides a visual summary of how Request Memoization works.

![request-memo](/articleAssets/2023-12/next-js-app-router-cache/request-memo.png)

### Data Cache

Request Memoization is great, but its lifetime is limited to a single render pass. This limitation becomes more apparent
when we want our data to persist across various user requests and pages, each of which might be going their own render passes.

Imagine a scenario involving four different users visiting a webpage showcasing city-specific travel guides.
This page contains articles and recommendations which are fetched from an API.

```jsx {4}
// /app/guides/[city]/page.js
export default async function Page({ params }) {
  const city = params.city;
  const res = await fetch(`https://api.globetrotter.com/guides/${city}`);
  const guideData = await res.json();

  return (
    <div>
      <h1>{guideData.title}</h1>
      <p>{guideData.content}</p>
      {/* Render the guide data */}
    </div>
  );
}
```

You might be thinking to yourself that wouldn't each user's visit trigger a separate data `fetch` request to the data source?
You have probably also recongized that this would be an inefficient and a resource-intensive process.

Thankfully, the Data Cache feature of Next.js is designed to address this very challenge. The Data Cache excels in optimizing performance and significantly enhancing user experience.

It caches and reuses data across multiple requests, even through application updates.
The persistence of the Data Cache means that once data is fetched and stored, it remains accessible across server restarts and deployments,
ensuring that your application is always primed with the necessary data.

Let's look at how our code above reaps the benefits of the Data Cache.

1. When User 1 makes a `fetch` request `https://api.globetrotter.com/guides/${city}`, Next.js goes straight to the Data Cache to check for a cached response.
2. Since this is the first time `fetch` is called, it results in a cache miss and the data is fetched from the data source, e.g. database.
3. The data is fetched from the source and is now stored in the Data Cache persistently.
4. When User 2, 3 and 4 make the same fetch request within the cache's revalidation period, they are served the cached response from the Data Cache.

In any application, we want to reduce the frequency of calls to our original data source.
With the Data Cache, we can offer a much better user experience.

#### `unstable_cache`

While we've primarily discussed the Data Cache in the context of caching `fetch` API responses, that's not the only thing its good for.

In our blog example from earlier, we were using the `fetch` API to cache data across requests. Sometimes we might want to fetch data directly from the database.
We can use `unstable_cache` function from Next.js to achieve this.

```jsx {4}
import { getGuides } from "./data";
import { unstable_cache } from "next/cache";

const getCachedGuides = unstable_cache(
  async (city) => getGuides(city),
  ["guides-cache-key"]
);

export default async function Page({ params }) {
  const guides = await getCachedGuides(params.city);
  // ...
}
```

In the code above, `getGuides` is a function that retrieves the guides based on a city from the database. For simplicity, I have left out the implementation.

The important part here is the `getCachedGuides` function. In our `unstable_cache` function, we are passing the `getGuides` function along with an array.
This array (`["guides-cache-key"]`) is like a key that acts as a category for our cache.
This means all cached user data retrieved through `getCachedGuides` will be stored and accessed using this key.

Using `unstable_cache` significantly reduces the need to repeatedly query the database for each new user request, maintaining efficiency across server requests.
At the time of writing this article, this API is unstable and may be updated by Next.js in the future.

#### Revalidation

While keeping the Data Cache enabled is great, there are scenarios when we want to delete the cached values and do a fresh fetch - revalidation.
The Data Cache is enabled by default and unless we opt out or set a revalidation period, the data remains cached indefinetely. In other words, it does not automatically revalidate or expire.

This might be a problem. From our example above, if a new article is published on the topic of "Best Cafes in Paris", we currently have no way of presenting the
subsequent users with the updated information. This won't make for a good user experience.

Next.js provides two solutions to our problem.

One of them is to revalidate the cache after a certain amount of time. This is known as **time-based revalidation**.

We could have our `Page` make a fresh `fetch` request to the data source every hour.

```jsx
// Revalidate at most every hour
const res = fetch(`https://api.globetrotter.com/guides/${city}`, {
  // 3600 seconds equal 1 hour
  next: { revalidate: 3600 },
});
```

As you can see in the code above we are using the `fetch.next.revalidate` option to refresh the cache every hour.

This solution doesn't fully address our problem though. If an article is uploaded before the cache revalidates, the users will get stale data. On the flip side, if no article is uploaded for a couple of hours we are refreshing the cache unncessarily.
It would be ideal to invalidate the cache and do a fresh fetch only when a new article is published.

##### `revalidatePath`

Next.js also provides on-demand revalidation which is exactly what we are looking for.

**On-demand revalidation** is useful when data needs to be refreshed based on a specific event.

In our case, we want to revalidate the cache when there is a new post in the blog.

```jsx {10}
import { revalidatePath } from "next/cache";

export async function publishArticle() {
  try {
    // ...
  } catch (error) {
    // ...
  }

  revalidatePath("/guides/paris");
}
```

The code above demonstrates on-demand revalidation in action. Every time `publishArticle` function is called, Next.js will attempt to regenerate `/guides/paris`.

`revalidatePath` function will purge all the server side cache for the `/guides/paris` route.
This means the next user to make a request will recieve the most up to date data, fetched directly from the source.

##### `revalidateTag`

Sometimes we need our cache revalidation to be more granular. That's where `revalidateTag` comes in handy.
It allows us to categorize and manage our cached data effectively using cache tags.

For example, when we fetch data, we can assign a cache tag like this:

```jsx
const res = fetch(`https://api.globetrotter.com/guides/${city}`, {
  next: { tags: ["city-guides"] },
});
```

Here, we're tagging our fetch request with `["city-guides"]`. This helps us in organizing our cache, making it easier to manage.

Now, let's say we've added new content and need to refresh our cache.

```jsx {10}
import { revalidatePath } from "next/cache";

export async function publishArticle() {
  try {
    // ...
  } catch (error) {
    // ...
  }

  revalidateTag("city-guides");
}
```

As you can see, we're specifically targeting and updating the cache for our `["city-guides"]` category.
This approach gives us a more targeted control over our cache, ensuring it's always up-to-date.

#### Opting out

Sometimes we might want to turn off the Data Cache completely. As an example, if we are showing a personalized dashboard that contains a user's private messages, we wouldn't want to cache those.
Next.js provides us with a couple of ways of opting out.

##### `no-store`

```jsx
// Revalidate at most every hour
const res = fetch(`https://api.globetrotter.com/guides/${city}`, {
  cache: "no-store",
});
```

As you can see in the code above, all we did was pass in `{cache:"no-store"}` as the second parameter to our `fetch`.
This now ensures that `fetch` requests will go directly to the data source, effectively disabling the Data Cache.

##### `export const dynamic = 'force-dynamic'`

We can also change the caching behavior of our entire page which is not specific to `fetch`.

```jsx
// /app/guides/[city]/page.js
export const dynamic = "force-dynamic";
```

Adding the above line of code at the very top of our `Page` means that the `Page` will be re-rendered on each request, ensuring that the content is always generated dynamically and is up-to-date.

##### `export const revalidate = 0`

Another way to opt the entire page out of caching is to use `export const revaliate = 0`.

Adding this line of code on top of our `Page` is semantically equivalent to `cache: "no-store"`, except it applies to requests across the entire page.

Some other scenarios when we might want to opt out of Data Cache include:

1. Real-time Data: A stock trading platform where users expect to see real-time price updates.
2. Security: Caching may pose a security risk, especially if sensitive data is involved.

Note that whether we choose to opt out of Data Cache or not, Next.js still memoizes the requests.

The diagram below demonstrates a step-by-step process of how Data Cache works.

![data-cache](/articleAssets/2023-12/next-js-app-router-cache/data-cache.png)

### Full Route Cache

Imagine we have a website featuring a list of blog posts. Our goal is to provide the fastest possible user experience while reducing the load on the server.

So far, we have talked about storing fetched data in cache but what about components and the HTML that is used to prepare a page to serve to the client? Without caching, every time a user requests a page, the server has to render the entire page from scratch.
If a page is complex or our server is under high traffic, this can be time-consuming, hence degrading the user's experience.

The Full Route Cache addresses this by storing the rendered page at build time, which refers to the time our application is being deployed.
And so because the page has already been rendered and cached, when a user requests it, the server can skip the rendering process and serve the cached version, significantly reducing response time and server load.
The Full Route Cache stores the HTML and something called React Server Component Payload (RSCP) of our pages.

Think of RSCP like a toolbox that contains all the instructions and rules for how the server-rendered components should integrate and interact with the client-side components.
It also contains placeholders for client components. Placeholders indicate where the client components fit into the overall structure of the page. This will make more sense in a bit.

```jsx {5}
import Link from "next/link";

async function getBlogList() {
  const blogPosts = await fetch("https://api.blogposts.com/1", {
    cache: "force-cache",
  });

  const blogData = await blogPosts.json();
  return blogData;
}

export default async function Page() {
  const blogData = await getBlogList();

  return (
    <div>
      <h1>Blog Posts</h1>
      <ul>
        {blogData.map((post) => (
          <li key={post.slug}>
            <Link href={`/blog/${post.slug}`}>
              <a>{post.title}</a>
            </Link>
            <p>{post.excerpt}</p>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

When `Page` above is being built or revalidated, the server will check the Full Route Cache for a cached version of `Page`.
Because this is the first time its being built or we just invalidated the cache, `Page` does not exist inside our cache.
This now means that the server is responsible for fetching the necessary data either from the Data Cache or the data source to render the page.

During the render process, the server also creates HTML and RSCP, which together store the rendered output in the Full Route Cache. Now, when a user requests `Page`, our server is able to use the cache to serve the already rendered page.

The biggest upside of using this cache is that it eliminates the need for the server to re-render the page from scratch for each request.

#### Revalidation

As we discussed, the Full Route Cache is only valid across multiple requests. And since it does not persist through deployments, redelpoying the app automatically invalidates the cache. This makes sense because we want users to receive
the most up-to-date content after a new deployment.

When the Data Cache is revalidated, it also revalidates the Full Route Cache. This is because caching of a full route depends on the data fetched for that route.
So, if the data required by a route is stored and retrieved from the Data Cache, it will influence the Full Route Cache.

#### Opting out

Full Route Cache caches static content. There are times when we will want to opt out.

For example, if we need to render user specific data based on their preferences and session data, not disabling the cache would result in different users seeing the same cached page. This is clearly not a good user experience.
Instead, we want to bypass the cache so we can dynamically render the page to cater for each user request.

##### Opt out of the Data Cache

As we just discussed, the Data Cache and Full Route Cache are linked. Therefore, we can skip the Data Cache and the Full Route Cache altogether by using `dynamic = 'force-dynamic'`
and `revalidate = 0`. You can go back to the Data Cache section to view the usage if you like.

Another way to opt out is by opting out of Data Cache for a specific route.

If we have a webpage that shows a user's profile information and the latest news,
we might decide that the profile information can be cached, but not the latest news section.
We can set up our `fetch` request for the news to opt out of the Data Cache - `{cache: 'no-store'}`.

As a result, the news is fetched fresh every time, but the profile information is quickly loaded from the cache.
However, because part of the page (the news) is always fetched fresh, the entire page can't be stored in the Full Route Cache, thus opting us out.

##### Dynamic Functions

Another way to opt out is by using dynamic functions. These dynamic functions ensure that routes which rely on specific, real-time request information (like cookies or headers) are always rendered dynamically, providing up-to-date content at the expense of bypassing the Full Route Cache.

The diagram below demonstrates the step-by-step process of how Full Route Cache works.

![full-route-cache](/articleAssets/2023-12/next-js-app-router-cache/full-route-cache.png)

<Tangent>
  This cache only works with your production builds since in development all
  pages are rendered dynamically, thus, they are never stored in this cache.
</Tangent>

### Router Cache

Every time a user navigates to a new route or revisits a previously accessed route,
the browser would need to re-fetch the data and re-render the page, which can be time-consuming and lead to a less responsive user experience.

The Router Cache addresses this by storing parts of pages (route segments) that users have already visited.
When a user navigates back to a previously visited route, the content can be quickly loaded from the cache, significantly speeding up the navigation process.

```jsx {10,11,12}
// /page
export default async function Page() {
  const blogData = await getBlogList();

  return (
    <div>
      <h1>Blog Posts</h1>
      <ul>
        {blogData.map((post) => (
          <li key={post.slug}>
            <Link href={`/blog/${post.slug}`}>
              <a>{post.title}</a>
            </Link>
            <p>{post.excerpt}</p>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

In the code above, when the user opens `/page`, the Router Cache stores the RSCP for the homepage. When the user navigates
to `/blog`, the Router Cache will store the RSCP for `/blog` as well. As the user navigates back to `/page`, instead of fetching and rendering the `/page` content from the server again, Next.js retrieves the RSCP for the `/page` from the Router Cache.
The homepage loads quickly since its content is served from the cache.

A side point is that Next.js analyzes the structure of a web page, particularly looking at `<Link>` components that the user might click on next.
It then preemptively fetches the data or resources for those linked pages. It also does this by default. We do have the option to disable it.

```jsx {10}
<Link href={`/blog/${post.slug}`} prefetch={false}>
  <a>{post.title}</a>
</Link>
```

If we don't want to prefetch the pages, we can simply use the `prefetch` property in the `<Link>` component and set it to `false` like in the code above.

#### Duration

##### Session

In our example above, the cache will persist so long as we navigate through the website using the navigation links. The cache is cleared when the user's session ends, such as when the browser or tab is closed, or the page is refreshed.

##### Automatic Invalidation Period

The full Router Cache caches parts of a page, called segments to optimize navigation and rendering performance. Each of these segments represent a portion of a page, which
could be a component or a specific route segment.
It stores the React Server Component Payload for each route segment during a user's session.
Each of these segments last for a specific duration before they become invalid (or stale). This duration is known as the automatic invalidation period.
These validation periods vary based on the whether the route is dynamic or static.

If we have a static route, the individual segments on that route will only last for 5 minutes before being revalidated. Whereas with dynamic routes, it comes down to 30 seconds.
For example, if we have a page with two main segments: a user profile section and a news feed section.
If the user profile section is accessed, its cache will be refreshed, and its invalidation period will restart from that moment.
However, the news feed section's cache will continue to age and will be invalidated independently if it reaches its invalidation period without being accessed or refreshed. This can be applied to both dynamic and static routes.

As you can probably tell, each individual segment's cache is independent, meaning the automatic invalidation period is based on its last access or creation time. While the set durations may seem limiting, especially for dynamic route, Next.js allows us to change the revalidation period for up to 5 minutes.
For this, all we have to do is to change the `prefetch` property to `true`.

#### Revalidation

There are several ways to revalidate the Router Cache.

We can revalidate the Router Cache on demand similar to how we did it for the Data Cache. If we invalidate the Data Cache using `revalidatePath` or `revalidateTag`,
we also end up revalidating the Router Cache.

Another way is to use the `router.refresh()` function. This function refreshes any route that is part of
the cache. It will re-fetch all the routes and re-render all the server side components.

This is useful as when a user comments on an article.
After submitting the comment, you want to show the updated comments section to the user.

```jsx
// After submitting a comment
router.refresh();
```

If our site has personalized content that changes based on user login status (like showing recommended articles), logging in or out should update what's displayed.

```jsx
// On login or logout
cookies.set("authToken", userToken); // or cookies.delete('authToken');
```

By using the above, we update the authentication cookies and the Router Cache is automatically invalidated.
This ensures that the user sees content relevant to their new authentication state.

#### Opting out

It is not possible to opt out of the Router Cache.

Here is an image that provides a visual summary of how the Router Cache works.

![router-cache](/articleAssets/2023-12/next-js-app-router-cache/router-cache.png)

### Build time Caching VS. Run time caching

##### Build time Caching

This refers to caching that occurs during the build process of the application. This type of caching is static and it doesn't change until the next build.
Full Route Cache stores the RSCP for each page, which is generated at build time. These pages are then served from the cache for each request. As we saw, with this caching, the server does not render these pages for each request.

Build time cache is only updated when the site is rebuilt/redeployed.

##### Run time Caching

Run time caching occurs when the application is accessed by users. It is great for dynamic data and changes based on runtime events and user interactions.

All other caching mechanisms, including Data Cache, Request Memoization and Router Cache fall under this category.

## Closing Notes

While the layered caching model can be difficult to wrap your head around in the beginning, Next.js takes a great approach in aiming to balance the performance of the application, along with data freshness.
As we saw, all of the caches work in concert but also have distinct roles.

Properly configured, these caching layers allow developers to build highly performant and responsive applications with Next.js, giving users a seamless experience while keeping server and client loads optimized. It's a sophisticated balance of performance, scalability, and maintaining up-to-date content.

And while the official documentation mentions that knowledge of caching is not necessary to be productive with Next.js, it helps a lot to understand its behavior so that you can configure the settings that work best for your particular app.

The table below summarizes all four caching mechanisms and their details.

| Cache               | Description                                               | Location | Revalidation Criteria                                                                              |
| ------------------- | --------------------------------------------------------- | -------- | -------------------------------------------------------------------------------------------------- |
| Request Memoization | Re-use values in same render pass for efficiency          | Server   | N/A, only lasts for the lifetime of a server request                                               |
| Data Cache          | Stores data across user requests and deployments          | Server   | Time-based or on-demand revalidation using `next.revalidate` option in `fetch`                     |
| Full Route Cache    | Caches static routes at build time to improve performance | Server   | Revalidated by revalidating Data Cache or redeploying the application                              |
| Router Cache        | Stores navigated routes to optimize navigation epxerience | Client   | Automatic invalidation after a specific time (30 seconds for dynamic, 5 minutes for static routes) |
