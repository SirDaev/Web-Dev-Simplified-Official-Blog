---
layout: "@layouts/BlogPost.astro"
title: "Next.js App Router Caching Mechanisms"
date: "2023-12-15"
description: "Next.js improves your application's performance and reduces costs by caching rendering work and data requests. This article goes in depth about everything you need to know about Next.js's caching mechanisms."
tags: ["Next.js"]
---

import Tangent from "@blogComponents/lib/Tangent.astro"

## Introduction

Next.js is an amazing framework that makes writing complex server rendered React apps much easier, but there is one huge problem. Next.js's caching mechanism is extremely complicated and can easily lead to bugs in your code that are difficult to debug and fix.

If you don't understand how Next.js's caching mechanism works it feels like you are constantly fighting Next.js instead of reaping the amazing benefits of Next.js's powerful caching. That is why in this article I am going to break down exactly how every part of Next.js's cache works so you can stop fighting it and finally take advantage of its incredible performance gains.

Before we get started, here is an image of how all the caches in Next.js interact with one another. I know this is overwhelming, but by the end of this article you will understand exactly what each step in this process does and how they all interact.

![cache-interactions](/articleAssets/2023-12/next-js-app-router-cache/cache-interactions.png)

In the image above, you probably noticed the term "Build Time" and "Request Time". To make sure this does not cause any confusion throughout the article, let me explain them before we move forward.

**Build time** refers to the time when we deploy our application. Anything that is cached during this process (mostly static content) will be part of the Build Time cache. Build time cache is only updated when the site is rebuilt/redeployed.

**Request time** refers to the time when the user requests a page. Typically, data cached at request time is dynamic as we want to fetch it directly from the data source when the user makes requests.

## Next.js Caching Mechanisms

Understanding Next.js's caching can seem daunting at first. It's not just one, but four distinct caching mechanisms at play, each operating at different stages of your application and interacting in ways that can initially appear complex.

Here are the four key caching mechanisms in Next.js:

1. Request Memoization
2. Data Cache
3. Full Route Cache
4. Router Cache

For each of the above, I will delve into their specific roles, where they're stored, their duration, and how you can effectively manage them, including ways to invalidate the cache and opt out options. By the end of this exploration, you'll have a solid grasp of how these mechanisms work together to optimize Next.js's performance.

### Request Memoization

If you have ever built an application before, you have probably had to fetch and display the same information in multiple places. As an example, if you are fetching some user data, it might need to be displayed in more than one place. There is one problem, though. If our `fetch` request is computationally heavy, this can increase the load on the server if it's continuously fetching from a data source. This becomes even more problematic when we consider the fact that user details are unlikely to change within a single request. So, it doesn't really make sense to make a fresh `fetch` call each time we want the user details.

Luckily, Request Memoization solves this exact problem. Whenever we make a `fetch` request in a render cycle (which basically just refers to the process of rendering all the components on a page), its result gets stored for any subsequent requests that have identical parameters.

```jsx {8,17 }
export default async function fetchUserData(userId) {
  // The `fetch` function is automatically memoized by Next.js during SSR
  const res = await fetch(`https://api.example.com/users/${userId}`);
  return res.json();
}

export default async function Page({ params }) {
  const user = await fetchUserData(params.id)

  return <>
    <h1>{user.name}</h1>
    <UserDetails id={params.id} />
  </>
}

function UserDetails({ id }) {
  const user = await fetchUserData(id)
  return <p>{user.name}</p>
}
```

In the simple code above, I have two components: `Page` and `UserDetails`. The first call to the `fetchUserData()` function in `Page` gets cached. The second call, invoked by `UserDetails`, does not actually create a new fetch request. Instead, it uses the memoized value. This feature significantly optimizes performance and efficiency during the rendering process. This cache is enabled by default to reduce the load on the server.

While this cache is on the server side, it's important to note that this cache is not permanent; it only lasts for the duration of a single render pass. Once the `Page` component finishes rendering, the cached `fetch` values are cleared.

#### Memoization requests other than `fetch`

While Request Memoization in Next.js is tailored only for the `GET` method in the `fetch` API, we can still memoize requests other than `fetch`, such as pulling data directly from the database.
To do this, we can uset React's `cache()` function.

```jsx
import { cache } from "react"
import { queryDatabase } from "./databaseClient" // Assume this is our database client function

export default async function fetchUserData(userId) {
  return cache(async () => {
    // Direct database query
    return queryDatabase("SELECT * FROM users WHERE id = ?", [userId])
  })
}
```

In this code above, the first time `fetchUserData()` is called, it queries the database directly, as there's no cached result yet. But the next time this function is called with the same `userId` in a different component, it smartly retrieves from the cache. Just like with `fetch`, this memoization is a one-time deal, valid only for the duration of a single render pass, but at least now we know that we aren't limited to `fetch`.

#### Revalidation

In Next.js, revalidation refers to the process of refreshing old cached data with new data straight from the database. This feature is vital for determining how long the data you serve stays up-to-date in the cache, ensuring that your users always have access to the most relevant information.

As of right now, there is no way we can revalidate the memoized values. This might seem like a limitation, but memoization is generally for a single render pass, and it's unlikely that your data will change in that short interval. Still, if you find yourself needing to revalidate, there is an option to opt out.

#### Opting out

To opt out of the cache, we can pass in an `AbortController` signal as a parameter to the `fetch` request.

```tsx {1, 4, 5}
const { signal } = new AbortController()
async function fetchUserData(userId) {
  // The `fetch` function is automatically memoized by Next.js during SSR
  const res = await fetch(`https://api.example.com/users/${userId}`, {
    signal,
  })
  return res.json()
}
```

In the above code, passing in the `signal` propety will treat each request as a new request, opting out of memoization.

The diagram below provides a visual summary of how Request Memoization works.

![request-memo](/articleAssets/2023-12/next-js-app-router-cache/request-memo.png)

<Tangent>
Request Memoization is a React feature, not exclusive to Next.js. I included it as it interacts directly with other caches.

</Tangent>

### Data Cache

The next cache I will discuss is the Data Cache. Request Memoization is not much use when we want to serve cached data to multiple users and reduce the load on the server. If your application has multiple user interactions and page visits, then each of them will have their own render cycle, and we want our cached data to persist beyond just the render cycle.

To do this, we can use the Data Cache, which is enabled by default in Next.js. The main reason to use this is so that the server is not refetching data each time a different user makes the same `fetch` request.

```jsx {3}
export default async function Page({ params }) {
  const city = params.city
  const res = await fetch(`https://api.globetrotter.com/guides/${city}`)
  const guideData = await res.json()

  return (
    <div>
      <h1>{guideData.title}</h1>
      <p>{guideData.content}</p>
      {/* Render the guide data */}
    </div>
  )
}
```

In the simple code I have above, all we are doing is making a `fetch` request to an API and dynamically passing in a `city` parameter so we can display travel guides for a given city. The main thing to focus on here is the `fetch` request. If there are four users accessing this page with the same city parameter, Next.js will `fetch` the data after the first user's request and store it in the Data Cache. This means that for the next three users, no actual fetch call is made as it's retrieved directly from the Data Cache. In other words, the Data Cache allows us to reduce calls to our original data source, providing a much smoother experience for our users.

#### `unstable_cache`

So far, we have only seen how to cache `fetch` requests with the Data Cache, but we can do much more than that.

If we go back to our previous example of city guides, we might want to pull data directly from our database. For this, we can use the `unstable_cache()` function that's provided by Next.js. This is like Next.js's version of the `cache()`, except it applies to the Data Cache.

```jsx {4}
import { getGuides } from "./data"
import { unstable_cache } from "next/cache"

const getCachedGuides = unstable_cache(
  async city => getGuides(city),
  ["guides-cache-key"]
)

export default async function Page({ params }) {
  const guides = await getCachedGuides(params.city)
  // ...
}
```

The code above is short, but it can be confusing if this is the first time you are seeing the `unstable_cache()` function being used, so let me explain.

I am using the `getGuides()` function to fetch guides from the database given a city (I left out its implementation as it's not important). Then, I am declaring a `const` called `getCachedGuides` and using it to store the result I get from calling the `unstable_cache()` function. You will notice there are two parameters: the `getGuides()` function and an array. This array `['guides-cache-key']` acts like a unique identifier and assigns our cached guides a category.

Then, when we call `getCachedGuides()` inside Page, it will act exactly the same as the fetch requests did previously with the Data Cache.

#### Revalidation

Data Cache does not expire unless you manually invalidate it. As an example, if we publish a new article to add to our city guides, our current setup won't automatically update the cached data for new visitors. Instead, it will present the cached data unless we specify some revalidation criteria.

There are two ways of dealing with this:

One approach is called time-based revalidation. This is pretty easy to grasp. Essentially, we set up our `Page` to make a new `fetch` request to our data source at regular intervals, like every hour. The time it accepts in the parameter is always in seconds.

```jsx
// Revalidate at most every hour
const res = fetch(`https://api.globetrotter.com/guides/${city}`, {
  // 3600 seconds equal 1 hour
  next: { revalidate: 3600 },
})
```

With the code above, our application will `fetch` the most updated data from the data source every hour. One potential problem with this approach for our use case is that if an article is added within the revalidation period, users will only see the update after it's revalidated. Also, if no new content is added for hours on end, our code will still refresh the Data Cache.

##### `revalidatePath`

When we want to invalidate the cache and fetch new data only when a new article is published or a specific event occurs, Next.js provides us with on-demand revalidation.

On-demand revalidation shines when you want to refresh data in response to specific events.

```jsx {10}
import { revalidatePath } from "next/cache"

export async function publishArticle() {
  try {
    // ...
  } catch (error) {
    // ...
  }

  revalidatePath("/guides/paris")
}
```

As you can see, each time `publishArticle` is called, Next.js gets the cue to regenerate the `/guides/paris` page.
This will clear the server-side cache, and the next visitor to request this will get the updated data.
It's a smart way to ensure users always have the latest info without unnecessary data fetching.

##### `revalidateTag`

In cases where we need a more precise approach to cache revalidation, Next.js offers a neat feature: `revalidateTag`.
We can control revalidation for specific tags.

```jsx
const res = fetch(`https://api.globetrotter.com/guides/${city}`, {
  next: { tags: ["city-guides"] },
})
```

Here, we're adding `["city-guides"]` tag to our `fetch` request so we can target it with `revalidatePath`.

```jsx {10}
import { revalidateTag } from "next/cache"

export async function publishArticle() {
  try {
    // ...
  } catch (error) {
    // ...
  }

  revalidateTag("city-guides")
}
```

Now we can pass in the tag - `revalidateTag("city-guides")` to zero in on the cache for our `city-guides` category.
This targeted approach ensures that our cache is always reflecting the most current data, without affecting unrelated cached content.

#### Opting out

There are a few straightforward ways to opt out of the Data Cache.

##### `no-store`

```jsx
const res = fetch(`https://api.globetrotter.com/guides/${city}`, {
  cache: "no-store",
})
```

In the example above, we've tweaked our `fetch` by adding `cache:"no-store"`. This opts a specific `fetch` request out of the Data Cache.

##### `export const dynamic = 'force-dynamic'`

If we want to change the caching behavior for an entire page and not just a specific `fetch` request, we can add this piece of code to the top level of our file.

```jsx
export const dynamic = "force-dynamic"
```

##### `export const revalidate = 0`

Another way to opt the entire page out of caching is to use `export const revalidate = 0`.

This line is pretty much the page-level equivalent of `cache: "no-store"`. It applies to all requests on the page, ensuring nothing gets cached.

Below is a diagram that walks you through how the Data Cache operates, step by step.

![data-cache](/articleAssets/2023-12/next-js-app-router-cache/data-cache.png)

### Full Route Cache

The third type of cache I will cover is the Full Route Cache, which is also enabled by default. The main reason this cache is useful is because it prevents Next.js from rebuilding static pages at request time. Instead, it caches them at build time and presents the user with this cached version, which reduces response times. This cache is the application of Build Time caching I mentioned earlier. While this is a high-level overview, I want to dive into a bit more detail on what exactly this cache is storing.

In Next.js, the pages we render to our clients consist of HTML and something called the React Server Component Payload (RSCP). The payload contains instructions for how the client components should work together with the rendered server components to render the page. The Full Route Cache stores the HTML and RSCP for static pages at Build Time.

Now that we know what it stores, let's take a look at an example.

```jsx
import Link from "next/link"

async function getBlogList() {
  const blogPosts = await fetch("https://api.blogposts.com/1", {
    cache: "force-cache",
  })

  const blogData = await blogPosts.json()
  return blogData
}

export default async function Page() {
  const blogData = await getBlogList()

  return (
    <div>
      <h1>Blog Posts</h1>
      <ul>
        {blogData.map(post => (
          <li key={post.slug}>
            <Link href={`/blog/${post.slug}`}>
              <a>{post.title}</a>
            </Link>
            <p>{post.excerpt}</p>
          </li>
        ))}
      </ul>
    </div>
  )
}
```

In the code I have above, `Page` will be cached at build time because it contains static data like blog posts. More specifically, its HTML and RSCP will be stored in the Full Router C ache so that it is served faster when a user requests access.
There is one thing, though. The first time we deploy our application, our Full Route Cache will be empty, and the data for `Page` will be fetched from the Data Cache or the data source. Only after that will it end up in the Full Route Cache.

#### Revalidation

So, as we just saw, this cache operates at build time, which means it will be invalidated whenever we redeploy our application. Another way to revalidate the cache is by resetting the Data Cache. This is because the caching of a full route depends on the data fetched for that route.

#### Opting out

If we want to fully turn off the Full Route Cache, Next.js provides two main ways of doing it. You might find this useful when the pages in your application are specific to the user so it doesn't make much sense to cache them.

##### Opt out of the Data Cache

As we previously discussed, the Data Cache and Full Route Cache are linked. We can skip both the Data Cache and the Full Route Cache altogether by using
`dynamic = 'force-dynamic'` and `revalidate = 0`. This approach is used in the same way as I demonstrated in the Data Cache section.

There is another way to opt out, which is a bit more complicated and not immediately obvious at first glance. We can opt out of the Full Route Cache by opting out of the Data Cache for a **specific** route. Essentially, Next.js does not allow you to use the Full Route Cache if you have only enabled the Data Cache for part of the page.

In our previous code snippet, if we changed the cache property from `cache: 'force-cache'` to `cache: 'no-cache'` in `getBlogList()` and added another function with the Data Cache enabled, we wouldn't be able to use the Full Route Cache.

##### Dynamic Functions

Using dynamic functions such as `cookies()` or `headers()` automiatically means that our route cannot be static because its impossible to know an HTTP request's headers and user's cookies at build time.

The diagram below demonstrates the step-by-step process of how Full Route Cache works.

![full-route-cache](/articleAssets/2023-12/next-js-app-router-cache/full-route-cache.png)

<Tangent>
  This cache only works with your production builds since in development all
  pages are rendered dynamically, thus, they are never stored in this cache.
</Tangent>

### Router Cache

The last cache I am going to talk about is the router cache. It is the only client-side cache in Next.js and can be the source of many bugs if not understood properly. This is mainly because it is enabled by default and caches routes that have already been visited before. Typically, the browser needs to re-fetch the data and re-render a page when it is visited again. This process, of course, takes longer than caching a page, which is why Next.js takes the caching approach. While this approach is an advantage when it comes to page loading speeds, it can also be quite frustrating. Let's take a look below at why.

```jsx {10,11,12}
// /page.jsx
export default async function Page() {
  const blogData = await getBlogList()

  return (
    <div>
      <h1>Blog Posts</h1>
      <ul>
        {blogData.map(post => (
          <li key={post.slug}>
            <Link href={`/blog/${post.slug}`}>
              <a>{post.title}</a>
            </Link>
            <p>{post.excerpt}</p>
          </li>
        ))}
      </ul>
    </div>
  )
}
```

In the code I have above, when the user navigates to `/page`, its RSCP gets stored in the Router Cache. Similarly, when we navigate to `/blog`, its RSCP also gets cached. The problem arises when we navigate back from `/blog` to `/page` within a certain period. This means that if we have anything dynamic on `/page`, it won't get updated until after the cache is invalidated or we refresh our page. Essentially, what's happening is that Next.js is retrieving the cached RSCP for `/page` from the Router Cache, sacrificing data freshness for performance. This approach might lead us to see stale data if we were expecting it to update upon navigation.

Before we jump into the details of revalidating this cache, it's worth noting a side point: by default, Next.js also analyzes the structure of our web page, paying special attention to `<Link>` components that the user might click on next. It then preemptively fetches the data or resources for those pages to make them load faster upon request.

```jsx {1}
<Link href={`/blog/${post.slug}`} prefetch={true}>
  <a>{post.title}</a>
</Link>
```

In the code above, I included `prefetch={true}` for demonstration but you can leave it out as that's the default setting. To opt out of this, we can just change it to `false`.

#### Duration

##### Session

The Router Cache lasts only as long as the user's session, meaning if the user closes the tab or refreshes the page, the cache will expire and be revalidated.

##### Automatic Invalidation Period

If the user session does not expire, Next.js also offers an automatic revalidation period depending on whether the route is static or dynamic.
To understand this further, let me explain what a route segment is. A segment refers to a part of the rendered page, such as a component. The Router Cache stores the RSCP for these segments and each of these segments have an automatic revalidation period associated with them, after which their cache expires.
For static routes this is 5 minutes and for dynamic routes, it is 30 seconds (though we can increase this to 5 minutes by adding `prefetch={true}` to the route). Let me illustrate this with a simple example.

If we have a page with two main segments: a user profile section and a news feed section, accessing the user profile section will invalidate its own cache and its revalidation period will start all over again.
If we don't interact with the news feed section until it expires, it will not be refreshed. In other words, the automatic invalidation period is based on the segment's last access or creation time.

#### Revalidation

We already discussed two ways of revalidation in the previous section but there are plenty of other ways to do it.

We can revalidate the Router Cache on demand similar to how we did it for the Data Cache. This means that revalidating Data Cache using `revalidatePath` or `revalidateTag` also revalidates the Router Cache.

##### `router.refresh()`

Another thing we can do is use the `router.refresh()` function. This function refreshes any route by re-rendering all the server side components with the updated data.

In our example, this is useful when a user comments on one of the blog posts. After submitting the comment, we want to show the updated comments section to the user.

```jsx
// After submitting a comment
router.refresh()
```

If our site has personalized content that changes based on user login status (like showing recommended articles), logging in or out should update what's displayed.

```jsx
// On login or logout
cookies.set("authToken", userToken) // or cookies.delete('authToken');
```

By using the above, we update the authentication cookies and the Router Cache is automatically invalidated.

#### Opting out

Currently, there is no way of opting out of the Router Cache. There are a lot of opinions around the soundness of this choice because if you are building a real-time system, the 30 seconds cache seems forced.
We can override it with `router.refresh()` as we discussed in the previous section but the scalability of this solution is questionable.

Here is an image that provides a visual summary of how the Router Cache works.

![router-cache](/articleAssets/2023-12/next-js-app-router-cache/router-cache.png)

## Conclusion

While the layered caching model can be difficult to wrap your head around in the beginning, Next.js takes a great approach in aiming to balance the performance of the application, along with data freshness.
As we saw, all of the caches work in concert but also have distinct roles.

And while the official documentation mentions that knowledge of caching is not necessary to be productive with Next.js, it helps a lot to understand its behavior so that you can configure the settings that work best for your particular app.

The table below summarizes all four caching mechanisms and their details.

| Cache               | Description                                               | Location | Revalidation Criteria                                                                              |
| ------------------- | --------------------------------------------------------- | -------- | -------------------------------------------------------------------------------------------------- |
| Request Memoization | Re-use values in same render pass for efficiency          | Server   | N/A, only lasts for the lifetime of a server request                                               |
| Data Cache          | Stores data across user requests and deployments          | Server   | Time-based or on-demand revalidation                                                               |
| Full Route Cache    | Caches static routes at build time to improve performance | Server   | Revalidated by revalidating Data Cache or redeploying the application                              |
| Router Cache        | Stores navigated routes to optimize navigation epxerience | Client   | Automatic invalidation after a specific time (30 seconds for dynamic, 5 minutes for static routes) |
